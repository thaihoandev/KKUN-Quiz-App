import React, { useEffect, useState, useCallback } from "react";
import { notification } from "antd";
import { useParams, useNavigate } from "react-router-dom";
import {
  getPagedQuestionsByQuizId,
  getQuizById,
  publishedQuiz,
  generateQuestionsByTopic,
  TopicGenerateRequest,
  addAiQuestionsToQuiz,
} from "@/services/quizService";

import QuestionEditorHeader from "@/components/headers/QuestionEditorHeader";
import QuestionEditorSidebar from "@/components/sidebars/QuestionEditorSidebar";
import AddQuestionByTypeModal from "@/components/modals/AddQuestionByTypeModal";
import AiSuggestionModal from "@/components/modals/AiSuggestionModal";
import TopicGenerateModal from "@/components/modals/TopicGenerateModal";

import { Question, Quiz } from "@/interfaces";
import QuizEditList from "./QuizEditList";

// ‚úÖ FIX 1: S·ª≠ d·ª•ng counter ƒë·ªÉ ƒë·∫£m b·∫£o unique key
let clientKeyCounter = 0;

function genIdFallback() {
  clientKeyCounter += 1;
  const timestamp = Date.now();
  const random = Math.random().toString(36).slice(2, 9);
  return `client_${timestamp}_${random}_${clientKeyCounter}`;
}

type WithClientKey<T> = T & { clientKey: string };

// ‚úÖ FIX 2: Kh√¥ng mutate object g·ªëc - t·∫°o shallow copy
function withClientKey<T extends { questionId?: string; clientKey?: string }>(
  arr: T[]
): WithClientKey<T>[] {
  if (!Array.isArray(arr)) return [];
  
  return arr.map((q) => {
    // N·∫øu ƒë√£ c√≥ clientKey h·ª£p l·ªá, gi·ªØ nguy√™n
    if (q.clientKey && typeof q.clientKey === 'string') {
      return { ...q } as WithClientKey<T>;
    }
    
    // N·∫øu c√≥ questionId, d√πng l√†m clientKey
    if (q.questionId) {
      return { ...q, clientKey: String(q.questionId) } as WithClientKey<T>;
    }
    
    // T·∫°o m·ªõi clientKey
    return { ...q, clientKey: genIdFallback() } as WithClientKey<T>;
  });
}

const QuizEditorPage: React.FC = () => {
  const { quizId } = useParams<{ quizId: string }>();
  const navigate = useNavigate();

  const [quiz, setQuiz] = useState<Quiz | null>(null);
  const [questions, setQuestions] = useState<WithClientKey<Question>[]>([]);
  const [loading, setLoading] = useState(true);
  const [showModal, setShowModal] = useState(false);
  const [publishing, setPublishing] = useState(false);

  // ‚úÖ Debug: Log khi questions thay ƒë·ªïi
  React.useEffect(() => {
    console.log('üìù Questions state updated:', questions.length);
    if (questions.length > 0) {
      console.log('üîë First 3 keys:', questions.slice(0, 3).map(q => 
        q.clientKey || q.questionId || 'NO_KEY'
      ));
    }
  }, [questions]);

  // pagination
  const [page, setPage] = useState<number>(0);
  const [size, setSize] = useState<number>(10);
  const [total, setTotal] = useState<number>(0);

  // AI form + preview
  const [topicModalOpen, setTopicModalOpen] = useState(false);
  const [aiModalVisible, setAiModalVisible] = useState(false);
  const [aiQuestions, setAiQuestions] = useState<Question[]>([]);
  const [aiLoading, setAiLoading] = useState(false);

  // bulk saving
  const [savingAi, setSavingAi] = useState(false);

  const fetchQuiz = useCallback(async () => {
    if (!quizId) return;
    try {
      const data = await getQuizById(quizId);
      setQuiz(data ?? null);
    } catch (err) {
      console.error("Error fetching quiz:", err);
    }
  }, [quizId]);

  const fetchQuestions = useCallback(async () => {
    if (!quizId) return;
    setLoading(true);
    try {
      const data = await getPagedQuestionsByQuizId(quizId, page, size);
      
      // ‚úÖ FIX 3: Validate data tr∆∞·ªõc khi set
      const content = Array.isArray(data?.content) ? data.content : [];
      const processed = withClientKey(content as Question[]);
      
      setQuestions(processed);
      setTotal(data?.totalElements ?? 0);
    } catch (err) {
      console.error("Error fetching questions:", err);
      notification.error({ 
        message: "Error", 
        description: "Unable to load the question list." 
      });
      setQuestions([]); // Reset v·ªÅ empty array
      setTotal(0);
    } finally {
      setLoading(false);
    }
  }, [quizId, page, size]);

  useEffect(() => { 
    fetchQuiz(); 
  }, [fetchQuiz]);
  
  useEffect(() => { 
    fetchQuestions(); 
  }, [fetchQuestions]);

  const handlePublish = async () => {
    if (!quizId) return;
    setPublishing(true);
    try {
      await publishedQuiz(quizId);
      notification.success({ 
        message: "Success", 
        description: "The quiz has been published successfully!" 
      });
    } catch (err) {
      console.error("Error publishing quiz:", err);
      notification.error({ 
        message: "Error", 
        description: "Failed to publish the quiz!" 
      });
    } finally {
      setPublishing(false);
    }
  };

  const onPageChange = (nextPage0: number, nextSize: number) => {
    if (nextSize !== size) { 
      setSize(nextSize); 
      setPage(0); 
    } else { 
      setPage(nextPage0); 
    }
  };

  // ‚úÖ FIX: Reset AI state ho√†n to√†n khi ƒë√≥ng modal
  const handleCloseAiModal = useCallback(() => {
    if (savingAi) return; // Kh√¥ng cho ƒë√≥ng khi ƒëang save
    
    setAiModalVisible(false);
    // ‚úÖ Delay ƒë·ªÉ tr√°nh flash UI
    setTimeout(() => {
      setAiQuestions([]);
      setTopicModalOpen(false);
    }, 300);
  }, [savingAi]);

  const handleAddSimilar = () => {
    // ‚úÖ Reset state tr∆∞·ªõc khi m·ªü modal m·ªõi
    setAiQuestions([]);
    setAiModalVisible(false);
    setTopicModalOpen(true);
  };

  // ‚úÖ FIX 4: Validate AI response tr∆∞·ªõc khi set
  const handleSubmitTopic = async (payload: TopicGenerateRequest) => {
    setAiLoading(true);
    try {
      const req = {
        ...payload,
        ...(quizId ? { quizId } : {}),
        dedupe: true,
      } as TopicGenerateRequest;
      
      const generated = await generateQuestionsByTopic(req);
      
      // ‚úÖ DEBUG: Log raw response
      console.log("üîç AI Raw Response:", generated);
      console.log("üîç Response type:", typeof generated);
      console.log("üîç Is array:", Array.isArray(generated));
      
      // Validate response
      if (!Array.isArray(generated)) {
        console.error("‚ùå AI response is not an array:", generated);
        throw new Error("Invalid AI response format");
      }
      
      // Filter out invalid questions
      const validQuestions = generated.filter((q, idx) => {
        const isValid = q && typeof q === 'object' && q.questionText;
        if (!isValid) {
          console.warn(`‚ö†Ô∏è Question #${idx} is invalid:`, q);
        }
        return isValid;
      });
      
      console.log(`‚úÖ Valid questions: ${validQuestions.length}/${generated.length}`);
      
      if (validQuestions.length === 0) {
        throw { __isEmptyAI: true, message: "No valid questions generated" };
      }
      
      // ‚úÖ Log first question structure
      console.log("üìã Sample question structure:", JSON.stringify(validQuestions[0], null, 2));
      
      setAiQuestions(validQuestions);
      setAiModalVisible(true);
      setTopicModalOpen(false);
    } catch (e: any) {
      const status = e?.__status;
      const isEmpty = e?.__isEmptyAI;
      let description = "Kh√¥ng th·ªÉ sinh c√¢u h·ªèi t·ª´ AI!";
      
      if (status === 503 || status === 429) {
        description = "H·ªá th·ªëng AI ƒëang b·∫≠n (503/429). Vui l√≤ng th·ª≠ l·∫°i sau v√†i gi√¢y.";
      } else if (isEmpty) {
        description = "AI tr·∫£ v·ªÅ r·ªóng ho·∫∑c sai ƒë·ªãnh d·∫°ng. H√£y c·ª• th·ªÉ h∆°n ch·ªß ƒë·ªÅ ho·∫∑c gi·∫£m s·ªë c√¢u.";
      } else if (e?.message) {
        description = e.message;
      }
      
      notification.error({ message: "Error", description });
      console.error("[AI] generateQuestionsByTopic error:", e);
    } finally {
      setAiLoading(false);
    }
  };

  // ‚úÖ FIX 5: S·ª≠ d·ª•ng functional update v√† reset state
  const handleAcceptAiQuestions = async (selected: Question[]) => {
    if (!quizId) return;
    
    console.log('üéØ handleAcceptAiQuestions called with:', selected.length, 'questions');
    
    if (!Array.isArray(selected) || selected.length === 0) {
      console.log('‚ö†Ô∏è No questions selected, closing modal');
      setAiModalVisible(false);
      // ‚úÖ Clear ngay khi kh√¥ng c√≥ g√¨ ƒë·ªÉ th√™m
      setTimeout(() => setAiQuestions([]), 300);
      return;
    }

    setSavingAi(true);
    try {
      console.log('üì§ Sending to API:', selected);
      const saved = await addAiQuestionsToQuiz(quizId, selected);
      console.log('üì• API Response:', saved);
      
      // Validate saved data
      if (!Array.isArray(saved)) {
        throw new Error("Invalid response from addAiQuestionsToQuiz");
      }
      
      const prepared = withClientKey(saved as Question[]);
      console.log('‚úÖ Prepared questions:', prepared.length);
      console.log('üîë Sample clientKeys:', prepared.slice(0, 3).map(q => q.clientKey));
      
      // ‚úÖ S·ª≠ d·ª•ng functional update ƒë·ªÉ tr√°nh race condition
      setQuestions(prev => {
        console.log('üìä Current questions:', prev.length);
        const updated = [...prepared, ...prev];
        console.log('üìä After merge:', updated.length);
        return updated;
      });
      
      setTotal(prev => {
        const newTotal = prev + prepared.length;
        console.log('üìä Total: ', prev, '‚Üí', newTotal);
        return newTotal;
      });

      notification.success({
        message: "ƒê√£ th√™m",
        description: `ƒê√£ l∆∞u ${prepared.length} c√¢u h·ªèi v√†o quiz`,
      });
      
      console.log('üéâ Success! Closing modal...');
      
      // ‚úÖ Reset state ho√†n to√†n
      setAiModalVisible(false);
      setSavingAi(false);
      
      // ‚úÖ Delay clear ƒë·ªÉ tr√°nh flash
      setTimeout(() => {
        console.log('üßπ Clearing AI questions from state');
        setAiQuestions([]);
        setAiLoading(false);
      }, 300);
      
    } catch (e: any) {
      console.error('‚ùå Error in handleAcceptAiQuestions:', e);
      setSavingAi(false);
      
      const status = e?.__status || e?.response?.status;
      let description = e?.message || "L·ªói khi th√™m c√¢u h·ªèi (bulk).";
      
      if (status === 400) {
        description = "D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Ki·ªÉm tra l·∫°i d·∫°ng c√¢u h·ªèi/ƒë√°p √°n.";
      }
      if (status === 404) {
        description = "Quiz kh√¥ng t·ªìn t·∫°i.";
      }
      
      notification.error({ message: "Error", description });
      console.error("[AI] addAiQuestionsToQuiz error:", e);
    }
  };

  // ‚úÖ FIX 6: S·ª≠ d·ª•ng immutable update cho time/points
  const handleTimeChange = useCallback((_qz: any, qidOrKey: string, t: number) => {
    setQuestions(prev => prev.map(q => {
      const key = q.questionId ?? q.clientKey;
      if (key !== qidOrKey) return q;
      
      // T·∫°o object m·ªõi thay v√¨ mutate
      return { ...q, timeLimit: t };
    }));
  }, []);

  const handlePointsChange = useCallback((_qz: any, qidOrKey: string, p: number) => {
    setQuestions(prev => prev.map(q => {
      const key = q.questionId ?? q.clientKey;
      if (key !== qidOrKey) return q;
      
      // T·∫°o object m·ªõi thay v√¨ mutate
      return { ...q, points: p };
    }));
  }, []);

  const fallbackSeedFromQuestions = questions
    .slice(-3)
    .map(q => q.questionText)
    .filter(Boolean)
    .join("; ");

  const topicSeed =
    (quiz?.title?.trim() || "") ||
    (quiz?.description?.trim() || "") ||
    fallbackSeedFromQuestions ||
    "";

  return (
    <div className="container-fluid bg-light" style={{ minHeight: "100vh" }}>
      <QuestionEditorHeader
        onBack={() => navigate(`/quizzes/${quizId}`)}
        onPublish={handlePublish}
        publishing={publishing}
      />

      <div className="container py-4">
        <div className="row">
          <QuestionEditorSidebar />
          <QuizEditList
            quizId={quizId ?? ""}
            questions={questions}
            loading={loading}
            page={page}
            size={size}
            total={total}
            onPageChange={onPageChange}
            onAddQuestion={() => setShowModal(true)}
            onTimeChange={handleTimeChange}
            onPointsChange={handlePointsChange}
            onAddSimilar={handleAddSimilar}
            aiLoading={aiLoading || savingAi}
          />
        </div>
      </div>

      <AddQuestionByTypeModal
        show={showModal}
        onHide={() => setShowModal(false)}
        onAddQuestion={(type) => {
          setShowModal(false);
          navigate(`/quizzes/${quizId}/questions/create?type=${type}`);
        }}
      />

      <TopicGenerateModal
        open={topicModalOpen}
        loading={aiLoading}
        onCancel={() => setTopicModalOpen(false)}
        initial={{
          topic: topicSeed,
          count: 5,
          questionType: "AUTO",
          timeLimit: 10,
          points: 1000,
          language: "vi",
        }}
        onSubmit={handleSubmitTopic}
      />

      <AiSuggestionModal
        show={aiModalVisible}
        loading={aiLoading || savingAi}
        questions={aiQuestions}
        onClose={handleCloseAiModal}
        onAccept={handleAcceptAiQuestions}
      />
    </div>
  );
};

export default QuizEditorPage;